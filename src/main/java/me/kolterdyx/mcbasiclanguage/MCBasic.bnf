{
  parserClass="me.kolterdyx.mcbasiclanguage.parser.MCBasicParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="MCBasic"
  psiImplClassSuffix="Impl"
  psiPackage="me.kolterdyx.mcbasiclanguage.psi"
  psiImplPackage="me.kolterdyx.mcbasiclanguage.psi.impl"

  elementTypeHolderClass="me.kolterdyx.mcbasiclanguage.psi.MCBasicTypes"
  elementTypeClass="me.kolterdyx.mcbasiclanguage.psi.MCBasicElementType"
  tokenTypeClass="me.kolterdyx.mcbasiclanguage.psi.MCBasicTokenType"

  psiImplUtilClass="me.kolterdyx.mcbasiclanguage.psi.impl.MCBasicPsiImplUtil"
}

mcbasicFile ::= item_*

private item_ ::= (statement|COMMENT|NEWLINE)+

statement ::= variableDeclaration
                | ifStatement
                | functionDeclaration
                | blockStatement
                | importStatement
                | returnStatement
                | execStatement
                | structDeclaration
                | expressionStatement

// STATEMENT

private blockStatement ::= PUNCTUATION_LBRACE statement* PUNCTUATION_RBRACE
private importStatement ::= KEYWORD_IMPORT (OP_MULTIPLY | IDENTIFIER (KEYWORD_AS IDENTIFIER)?) KEYWORD_FROM STRING_LITERAL PUNCTUATION_SEMICOLON
private variableDeclaration ::= KEYWORD_LET IDENTIFIER type OP_ASSIGN expression PUNCTUATION_SEMICOLON
private ifStatement ::= KEYWORD_IF PUNCTUATION_LPAREN expression PUNCTUATION_RPAREN blockStatement (KEYWORD_ELSE blockStatement | ifStatement)?
private functionDeclaration ::= KEYWORD_FUNC IDENTIFIER PUNCTUATION_LPAREN parameterList? PUNCTUATION_RPAREN blockStatement
private returnStatement ::= KEYWORD_RETURN expression? PUNCTUATION_SEMICOLON
private execStatement ::= KEYWORD_EXEC expression PUNCTUATION_SEMICOLON
private structDeclaration ::= KEYWORD_STRUCT IDENTIFIER PUNCTUATION_LBRACE structField* PUNCTUATION_RBRACE
private expressionStatement ::= expression PUNCTUATION_SEMICOLON


// EXPRESSION

private expression ::= or

private or ::= and (OP_OR and)*
private and ::= equality (OP_AND equality)*
private equality ::= relational (EQ_OPERATORS relational)*
private relational ::= additive (RELATIONAL_OPERATORS additive)*
private additive ::= multiplicative (ADDITIVE_OPERATORS multiplicative)*
private multiplicative ::= unary (MULTIPLICATIVE_OPERATORS unary)*
private unary ::= (UNARY_OPERATORS unary) | value
private value ::= baseValue (postFix*)?
private baseValue ::= IDENTIFIER | primary
private postFix ::= arrayAccess | functionCall | memberAccess
private primary ::= literal | PUNCTUATION_LPAREN expression PUNCTUATION_RPAREN


// COMPONENTS


private arrayAccess ::= PUNCTUATION_LBRACKET expression PUNCTUATION_RBRACKET
functionCall ::= PUNCTUATION_LPAREN argumentList? PUNCTUATION_RPAREN
memberAccess ::= PUNCTUATION_DOT IDENTIFIER

private parameterList ::= IDENTIFIER (PUNCTUATION_COMMA IDENTIFIER)* PUNCTUATION_COMMA?
private argumentList ::= expression (PUNCTUATION_COMMA expression)* PUNCTUATION_COMMA?

private literal ::= STRING_LITERAL
                | INTEGER_LITERAL
                | DOUBLE_LITERAL
                | TRUE_LITERAL
                | FALSE_LITERAL
                | LIST_LITERAL

private LIST_LITERAL ::= PUNCTUATION_LBRACKET argumentList PUNCTUATION_RBRACKET
private type ::= listType | baseType
private baseType ::= KEYWORD_INT
                     | KEYWORD_STR
                     | KEYWORD_DOUBLE
                     | IDENTIFIER
private listType ::= baseType PUNCTUATION_LBRACKET PUNCTUATION_RBRACKET

private structField ::= IDENTIFIER type PUNCTUATION_SEMICOLON

// OPERATORS

private EQ_OPERATORS ::= OP_EQUAL
                            | OP_NOT_EQUAL
private RELATIONAL_OPERATORS ::= OP_LESS
                           | OP_GREATER
                           | OP_LESS_EQUAL
                           | OP_GREATER_EQUAL

private ADDITIVE_OPERATORS ::= OP_PLUS
                            | OP_MINUS

private MULTIPLICATIVE_OPERATORS ::= OP_MULTIPLY
                                    | OP_DIVIDE
                                    | OP_MODULO

private UNARY_OPERATORS ::= OP_NOT
                             | OP_MINUS

OP_EQUAL ::= "=="
OP_NOT_EQUAL ::= "!="
OP_LESS ::= "<"
OP_GREATER ::= ">"
OP_LESS_EQUAL ::= "<="
OP_GREATER_EQUAL ::= ">="
OP_PLUS ::= "+"
OP_MINUS ::= "-"
OP_MULTIPLY ::= "*"
OP_DIVIDE ::= "/"
OP_MODULO ::= "%"

// PUNCTUATION

PUNCTUATION_COMMA ::= ","
PUNCTUATION_SEMICOLON ::= ";"
PUNCTUATION_LPAREN ::= "("
PUNCTUATION_RPAREN ::= ")"
PUNCTUATION_LBRACE ::= "{"
PUNCTUATION_RBRACE ::= "}"
PUNCTUATION_LBRACKET ::= "["
PUNCTUATION_RBRACKET ::= "]"
PUNCTUATION_DOT ::= "."